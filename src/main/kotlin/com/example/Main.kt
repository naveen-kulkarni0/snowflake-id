package com.example

import kotlinx.coroutines.*
import kotlinx.coroutines.sync.Mutex


const val NODE_ID_BITS = 10
const val SEQUENCE_BITS = 12
const val maxSequence = (1L shl SEQUENCE_BITS) - 1
const val nodeId: Long = 0 // hardcoding this to 0 to mimic 1 mill id being generated by 1 system
var sequence = 0L

private val mutex = Mutex()

fun main() = runBlocking {
    val start = getEpochMs()
    val scope = CoroutineScope(Dispatchers.Default)

    for (i in 1..1_000_000) {
        scope.launch {
            snowflake()
        }
    }

    // Keep the scope active until all coroutines finish
    scope.coroutineContext.cancelChildren()
    val total = getEpochMs() - start
    println("Total time taken $total")

}

suspend fun snowflake(){
    val ts = getEpochMs()
    val seq = getSequenceNumber()
    val id = (ts shl (NODE_ID_BITS + SEQUENCE_BITS) or (nodeId shl SEQUENCE_BITS)
            or seq)
    println(id)
}

fun getEpochMs(): Long{
    return System.currentTimeMillis()
}

suspend fun getSequenceNumber(): Long {
    mutex.lock()
    try {
        sequence = (sequence + 1) and maxSequence // Simplified sequence increment and wraparound
        return sequence
    } finally {
        mutex.unlock()
    }
}